Windows has a variety of synchronization mechanisms, used to coordinate activity between threads. Locks (mutual exclusion) are the most obvious ones, but there are also synchronization mechanisms for signaling an event, sharing ownership of a resource, among others. The CLR (and the .NET Framework) wraps some Windows synchronization mechanisms directly (for example, the Mutex and Semaphore classes). The CLR also adds synchronization mechanisms that are only loosely based on Windows equivalents, such as the Monitor class (the mechanism used by the C# lock statement).
 
First, acquaint yourself with the fundamentals of CLR synchronization using Joe Albahari's excellent tutorial (feel free to read the rest of the tutorial too, if you're so inclined): http://www.albahari.com/threading/part2.aspx
 
CLRMD has support for enumerating the blocking objects (synchronization mechanisms) for which a thread is waiting. This is provided by a simple ClrThread.BlockingObjects collection. However, CLRMD only recognizes waits in managed threads, and can provide detailed data only for waits that involve CLR locks (such as Monitor). We would like to build upon the support provided by CLRMD, to enumerate all kinds of waits performed by threads -- and not only managed threads.
 
When a thread waits for a synchronization mechanism, it does so by invoking one of a small set of Windows APIs: WaitForSingleObject(Ex), WaitForMultipleObjects(Ex), and a couple of others. These APIs are well-documented (e.g. https://msdn.microsoft.com/en-us/library/windows/desktop/ms687069(v=vs.85).aspx), and we can obtain their parameters using the code you wrote in Assignment 2. In the next assignment, we will also obtain information about individual synchronization objects; for now, we just want the handles.
 
Write code that attaches to a given process (or dump file), enumerates all its threads -- including unmanaged ones, and prints out details about the synchronization objects for which each thread is waiting. Specifically:
· If a thread is a managed thread (represented by a ClrThread object), inspect its BlockingObjects collection. If it's not empty, print out the details and stop. 
· If a managed thread doesn't have anything in its BlockingObjects collection, or if a thread is unmanaged in the first place, inspect its stack (from the top down) and look for the Windows wait API calls: WaitForSingleObject(Ex), WaitForMultipleObjects(Ex). Print out the handle or handles of the synchronization mechanisms for which the thread is waiting. 
 
You can test your implementation by writing a small program that P/Invokes into the Windows wait APIs. Take a look at the pinvoke.net declaration for these APIs, for example: http://www.pinvoke.net/default.aspx/kernel32.waitformultipleobjects
